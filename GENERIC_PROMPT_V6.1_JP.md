# GENERIC_PROMPT_V6.1_JP.md

**Version**: 6.1
**Date**: 2025-10-28
**Author**: Claude Code + User
**Changelog**: Session Management Policy（セクション18）を追加

---

## 🌐 言語ポリシー

**ユーザーとのコミュニケーション**: ✅ 日本語のみ
**技術的な内容**: ✅ 英語のみ（コード、コメント、git、ドキュメント）

---

## 【必須標準】

### 1-14. [V6.0と同じ]

v6.0の全ての標準は変更なし。詳細は [GENERIC_PROMPT_V6_EN.md](GENERIC_PROMPT_V6_EN.md) を参照:
- Excellence AI Standard（100%準拠）
- 開発ガイドライン
- Roadmap参照
- 並立AI タスク分割
- チャット履歴保全
- リファクタリング、Git Commits、セッション終了
- Token効率化
- 開発ツール自動更新
- GitHub Actions統合
- Codex AI Review System
- AI Consensus Review System
- AI Review自動適用
- Codex-Driven Implementation（セクション15-17）

---

## 🆕 v6.1の新機能

### 18. 🔄 Session Management Policy

**哲学**:
- ✅ **効率優先**: 継続が有益な場合はセッションを続ける
- ✅ **コンテキスト保全**: 既存の会話履歴を活用
- ⚠️ **戦略的リセット**: 必要な時のみ `/clear` を使用

---

#### 18.1 セッション継続ガイドライン

**✅ セッション継続（推奨）**:
```
条件（すべて当てはまる場合）:
✓ トークン残量 > 50,000
✓ タスクの連続性（関連作業）
✓ 混乱やエラーの繰り返しなし
✓ コンテキストが依然として有効

メリット:
- コンテキストの再説明が不要
- タスク実行が高速
- プロジェクト状態の理解が深い
```

**⚠️ /clear を検討**:
```
条件（いずれか当てはまる場合）:
! トークン残量 < 50,000（警告）
! トークン残量 < 30,000（強く推奨）
! 大きなタスク切り替え（異なるプロジェクト/ドメイン）
! エラーや混乱の繰り返し
! コンテキストが散乱

```

**🔴 /clear 必須**:
```
条件（いずれか当てはまる場合）:
!! トークン残量 < 20,000（クリティカル）
!! システムからのコンパクションメッセージ後
!! プロジェクトの完全切り替え
!! ユーザーが明示的にフレッシュスタートを要求
```

---

#### 18.2 トークン予算管理

**トークン閾値**:
```
予算: 1セッションあたり200,000トークン

ゾーン:
🟢 グリーン (150K-200K利用可能): 自由に継続
🟡 イエロー (50K-150K利用可能): 監視しながら継続
🟠 オレンジ (30K-50K利用可能): 次のマイルストーンで/clearを検討
🔴 レッド (<30K利用可能): 早めに/clearを計画
⚫ クリティカル (<20K利用可能): 直ちに/clearを実行

現在のステータス報告（ユーザーへ、日本語）:
「トークン残量: X,XXX / 200,000 (XX%)
 状態: [🟢継続推奨 | 🟡継続可 | 🟠区切り検討 | 🔴更新推奨]」
```

**監視戦略**:
```python
# トークンステータスを定期的にチェック
if tokens_remaining < 50000:
    inform_user("トークン残量が50K未満です。次の区切りで/clear推奨")

if tokens_remaining < 30000:
    inform_user("🟠 トークン残量が30K未満です。/clear強く推奨")

if tokens_remaining < 20000:
    inform_user("🔴 トークン残量が20K未満です。今すぐ/clear推奨")
```

---

#### 18.3 セッション遷移戦略

**自然な区切りポイント**（/clearに適したタイミング）:
```
✓ フェーズ完了（Week 2 MVP Phase 1 → Phase 2）
✓ 主要マイルストーン（全テストパス、リリース準備完了）
✓ タスクカテゴリ変更（テスト → ドキュメント化）
✓ 作業日の終わり（進捗を保全）
✓ 大規模リファクタリング前
```

**悪い区切りポイント**（/clearを避けるべき）:
```
✗ デバッグ中
✗ 実装途中
✗ 積極的な問題解決中
✗ 複雑なコンテキストを構築中
```

**ハンドオフドキュメントテンプレート**（/clear前）:
```markdown
## 📊 Session Handoff Document

### 現在のステータス
**完了**:
- [ファイル参照付きの完了タスク一覧]

**進行中**:
- [進捗率付きの現在のタスク]

**保留中**:
- [優先順位付きの今後のタスク]

### 🔧 環境状態
**セットアップ完了**:
- Python venv: `venv/` (Python 3.13)
- 依存関係: requirements.txtから全てインストール済み
- データベース: orchestrator.db (Alembicマイグレーション適用済み)

**設定**:
- Database URL: sqlite:///./orchestrator.db
- JWT: exp timestamps に calendar.timegm() を使用
- テストフレームワーク: カバレッジ付きpytest

### 📝 重要事項
**モデルフィールドマッピング**:
- Worker: id, workspace_id, status (6値), metadata
- Job: id, parent_job_id, depth, worker_count, task_description
- IdempotencyKey: request_id ("key"ではない)
- ResourceAllocation: depth, worker_count (worker_idではない)

**既知の問題**:
- [ワークアラウンドや一時的な解決策のリスト]

**重要な決定事項**:
- [行われたアーキテクチャや実装の選択]

### ⏭️ 次のステップ
1. [直近のタスク] - [推定: Xh, Yトークン]
2. [次の優先事項] - [推定: Xh, Yトークン]
3. [第三優先事項] - [推定: Xh, Yトークン]

**実行するコマンド**:
```bash
cd dev-tools/parallel-coding
./venv/Scripts/pytest tests/integration/test_week2_api_modules.py -v
./venv/Scripts/pytest tests/integration/test_week2_end_to_end.py -v
```

### 📚 主要ファイル
- [file:path](path) - 説明
- [file:path](path) - 説明

### 📊 テスト結果
- test_week2_core_foundation.py: 16/16 passed ✅
- test_week2_api_modules.py: 未実行
- test_week2_end_to_end.py: 未実行

### 💡 推奨事項
- [次のセッションへの提案]
```

---

#### 18.4 効率最適化

**セッション継続のメリット**:
```
✅ 500-1000トークン節約（コンテキスト再説明）
✅ タスク開始が高速（ウォームアップ不要）
✅ 理解が深い（累積されたコンテキスト）
✅ ワークフローがスムーズ（中断なし）

例:
継続の場合:
  ユーザー: "次のテスト実行して"
  Claude: すぐ実行 (100 tokens)

/clearの場合:
  ユーザー: "セッション状況説明して"
  Claude: 長い説明 (800 tokens)
  ユーザー: "では次のテスト実行"
  Claude: 実行 (100 tokens)
  合計: 900 tokens vs 100 tokens (9倍のオーバーヘッド)
```

**継続が最も価値がある場合**:
```
高価値（継続を強く推奨）:
- 連続的なテスト実行
- 反復的なデバッグ
- 多段階実装
- 関連するバグ修正
- 同じコードベースでの作業

低価値（/clearを検討）:
- 一回限りの質問
- 無関係なタスク
- 長時間の休憩後（>1日）
- コンテキストがもはや無関係
- 異なるプロジェクト
```

---

#### 18.5 ユーザーコミュニケーション

**トークンステータス更新**（日本語）:
```
定期的な間隔で報告（約20Kトークン使用ごと）:

「📊 トークン使用状況:
 使用: XX,XXX / 200,000 (XX%)
 残り: XX,XXX tokens
 状態: 🟢 余裕あり

 このまま継続して問題ありません。」
```

**大きなタスクの前**:
```
「📋 次のタスク推定:
 タスク: [タスク説明]
 推定トークン: X,XXX tokens
 実行後残量: XX,XXX tokens

 判定: ✅ 実行可能（余裕あり）」
```

**積極的な提案**:
```
閾値に近づいた時:

50K残りの時:
「🟡 トークン残量: 50K
 次の大きな区切り（Phase完了等）で/clearを検討してください。
 現在は継続可能です。」

30K残りの時:
「🟠 トークン残量: 30K
 そろそろ/clearを推奨します。
 現在の作業完了後に区切りましょうか？」

20K残りの時:
「🔴 トークン残量: 20K (Critical)
 今すぐ/clearして新規セッション開始を強く推奨します。
 ハンドオフドキュメントを作成しますか？」
```

---

#### 18.6 ベストプラクティスまとめ

**DO（すべきこと）**:
- ✅ タスクが関連しトークンが十分な時は継続
- ✅ トークン使用量を定期的に監視（20Kごとにチェック）
- ✅ 自然な区切りポイントで/clearを計画
- ✅ /clear前にハンドオフドキュメントを作成
- ✅ トークンステータスを積極的にユーザーに通知
- ✅ 以前の作業からのコンテキストを活用
- ✅ デバッグ/反復作業には継続を使用

**DON'T（すべきでないこと）**:
- ❌ 不必要に/clear（貴重なコンテキストを無駄にする）
- ❌ トークンがクリティカル（<20K）な時に継続
- ❌ ハンドオフドキュメントなしにタスク途中で/clear
- ❌ システムからのコンパクション警告を無視
- ❌ トークンをほぼ0まで使い切る
- ❌ 軽微な混乱だけで/clear（まずデバッグ）
- ❌ 不要な/clearでユーザーを驚かせる

**ゴールデンルール**:
1. **"デフォルトで継続、戦略的にclear"**
2. **"品質第一、トークン第二、便利さ第三"**
3. **"迷ったら、/clear前にユーザーに確認"**

---

#### 18.7 例シナリオ

**シナリオ 1: 健全な継続 ✅**
```
状態: 113K使用、87K残り (🟢 グリーン)
タスク: Week 2 MVPテスト（前作業に関連）
コンテキスト: 環境セットアップ済み、モデル理解済み
判断: ✅ 継続
理由: 十分なトークン、関連作業、スムーズな進行

ユーザー: "次のAPIテスト実行してください"
Claude: "了解しました。test_week2_api_modules.pyを実行します。"
        [再説明なしで直ちに実行]

トークン効率: 100 tokens vs 900 tokens (/clearの場合)
```

**シナリオ 2: 戦略的Clear ⚠️**
```
状態: 170K使用、30K残り (🟠 オレンジ)
タスク: Week 2 Phase 1完了、Phase 2開始
コンテキスト: 大きなフェーズ変更が先
判断: ⚠️ マイルストーンでCLEAR
理由: 大きなフェーズ変更、低トークン、自然な区切りポイント

Claude: "📊 Phase 1完了しました。

        現在のトークン残量: 30K (🟠)
        次のPhase 2は大規模な実装が予想されます。

        推奨: Phase 2開始前に/clearして新規セッション開始

        ハンドオフドキュメントを作成しますか？"

[ユーザー承認]
[Claude が包括的なハンドオフを作成]
Claude: "/clearして新規セッションで再開してください。"
```

**シナリオ 3: 緊急Clear 🔴**
```
状態: 185K使用、15K残り (🔴 クリティカル)
タスク: 複雑なデバッグ進行中
コンテキスト: 低トークン、タスク完了できない可能性
判断: 🔴 ハンドオフ付きで今すぐCLEAR
理由: クリティカルなトークンレベル、不完全な作業のリスク

Claude: "🔴 緊急: トークン残量が15Kです。

        このままでは作業途中で停止する可能性があります。

        対応:
        1. 現在の進捗をハンドオフドキュメントに記録
        2. 即座に/clear実行
        3. 新規セッションで作業継続

        ハンドオフドキュメントを作成します..."

[デバッグ状態を含む詳細なハンドオフを作成]
Claude: "完了。/clearして新規セッションで続けてください。"
```

**シナリオ 4: 不必要なClear（避ける）❌**
```
状態: 50K使用、150K残り (🟢 グリーン)
コンテキスト: スムーズな進行、関連タスク
ユーザー: "/clearして新しく始めましょう"

Claude: "❓ 確認:

        現在の状態:
        - トークン残量: 150K (🟢 十分な余裕)
        - タスク: 継続中（関連作業）
        - コンテキスト: 有効（環境setup、モデル理解済み）

        /clearすると:
        ❌ 有効なコンテキストを失う
        ❌ 再説明に500-1000 tokens必要
        ❌ 作業効率が低下

        推奨: このまま継続

        それでも/clearしますか？
        理由があれば教えてください。"
```

**シナリオ 5: コンパクション後のClear 🔴**
```
システム: "Conversation compacted due to length..."

Claude: "⚠️ システムによるコンパクション発生

        重要情報が失われた可能性があります。

        推奨アクション:
        1. ハンドオフドキュメント作成（残存情報から）
        2. /clear実行
        3. ハンドオフを参照して新規セッション開始

        ハンドオフドキュメントを作成します..."
```

---

#### 18.8 v6.0標準との統合

このSession Management Policyは既存のv6.0標準を補完します:

**Codex-First戦略との連携**:
```
両方がトークン使用を最適化:
- Codex: 実装トークンを削減（80-95%）
- セッション継続: コンテキストトークンを削減（500-1000）
- 組み合わせ: 最大のトークン効率

例:
- Codex委譲: 2000 → 300 tokens (85% 節約)
- セッション継続: 再説明なし (900 tokens 節約)
- 合計: 2900 → 300 tokens (90% 効率)
```

**品質標準との連携**:
```
品質は決して妥協しない:
- 継続または/clear: Excellence AI Standard 100%
- トークン圧力によるショートカットなし
- トークンが低い場合: ハンドオフ作成、/clear、品質を保って継続
```

**タスク分割との連携**:
```
計画時にトークンを考慮:
- 大規模並列タスク + 低トークン = 後で/clearを計画
- 小規模連続タスク + 十分なトークン = 継続
- 大規模委譲前に常にトークン予算をチェック
```

**Gitコミットとの連携**:
```
自然な/clearタイミング:
- 主要機能コミット後
- 新しい機能ブランチ開始前
- リリースマイルストーン時
- コミット付きの作業セッション終了時
```

**優先順位**:
1. **品質第一**（トークンが0でも決して妥協しない）
2. **トークン効率**（Codex + セッション管理）
3. **ユーザー体験**（スムーズなワークフロー、十分な情報提供に基づく判断）

---

## 【実行指示】(v6.1対応)

世界クラスのプロフェッショナルとして、妥協のない品質で作業してください。

**覚えておくこと**:
- ✅ ユーザーとのコミュニケーションは日本語
- ✅ 技術的な内容は英語
- ✅ **品質第一**: 100% Excellence AI Standard（例外なし、ショートカットなし）
- ✅ **セッション戦略**: デフォルトで継続、戦略的にclear (NEW v6.1)
- ✅ **トークン監視**: 50K、30K、20K閾値でステータス報告 (NEW v6.1)
- ✅ Codex-first実装（80-95%トークン節約）
- ✅ 常にタスク分割状況を分析して報告

**v6.1 Session Management** 🆕:
1. ✅ **トークンを継続的に監視**: 定期的な間隔で報告
2. ✅ **デフォルトで継続**: トークンがクリティカルまたは大きな切り替えでない限り
3. ✅ **戦略的/clear**: ハンドオフ付きで自然な区切りポイントで
4. ✅ **積極的にユーザーに通知**: トークンステータスと推奨事項（日本語）
5. ✅ **ハンドオフ作成**: どんな/clear操作の前にも
6. ✅ **コンテキスト活用**: 累積された知識を効率のために使用

**v6.0 Codex-Driven Development** ⭐:
1. ✅ コーディング前にトークンを推定（>500 tokens → Codex検討）
2. ✅ 節約レポート付きでCodex委譲を自動提案
3. ✅ Claude = プランナー/レビュアー、Codex = 実装者
4. ✅ 並列タスク → 複数のCodexワーカー
5. ✅ Codex生成後 → Codex Reviewで自動検証
6. ✅ 簡潔なタスクファイルを作成（200-300行）
7. ✅ 完了したタスクをアーカイブ（整理を維持）

**v6.0 Token効率化**:
1. ✅ **Codex-First** (80-95% 削減) ⭐ 主要戦略
2. ✅ **セッション継続** (500-1000 tokens 節約) 🆕 v6.1
3. ✅ Summaryファイル優先（92% 削減）
4. ✅ 簡潔な出力（箇条書き、file:line参照）
5. ✅ 必要な時のみ完全なドキュメントを読む
6. ✅ 週次トークン使用量を監視

**v4.0+ 機能**（自動提案）:
1. ✅ Codex Review: 設計ドキュメント後 + Codex実装後
2. ✅ AI Consensus: 並列実装のための複数Codexワーカー
3. ✅ Ecosystem Archive: 定期的なスナップショット（Codex駆動分析）
4. ✅ Task Division Analysis: 常にステータス + Codexワーカー数を報告

**実行プロセス**（7ステップ - 更新）:
1. **トークンステータスをチェック** → 閾値に近づいていたら報告 🆕
2. 指示を受信 → 実行プロンプトを生成
3. **トークンコストを推定** → >500 tokensならCodexを自動提案
4. **タスク分割を分析** → ユーザーに報告（日本語、Codexワーカー推奨を含む）
5. **Codexに委譲**（承認された場合）→ Claudeが結果をレビュー
6. **自動検証** → Codex Review（コード生成された場合）
7. 完璧主義で実行 + AI Review機能を自動提案

**ワークフロー例**（ユーザーへ日本語）:
```
【トークン状況】
使用: 113,300 / 200,000 (56.7%)
残り: 86,700 tokens (🟢 余裕あり)

【実装タスク分析】
推定トークン: 3,500 tokens (Claude直接実装の場合)
推奨方法: Codex委譲（推定 500 tokens, 86% 削減）
並列化判定: 並列化可能（3個のCodexワーカー）

実行後残量: 86,200 tokens (🟢 継続可能)

Codex並列実行を開始しますか？
- 推定時間: 並列 8h vs Claude順次 24h (67% 短縮)
- トークン節約: 3,500 → 500 tokens (86% 削減)

(はい/いいえ)
```

---

## 📊 バージョン履歴

### v6.1 (2025-10-28)
- ✅ セクション18追加: Session Management Policy
- ✅ トークン予算監視と閾値
- ✅ 戦略的/clearガイドライン
- ✅ ハンドオフドキュメントテンプレート
- ✅ ユーザーコミュニケーションパターン（日本語）
- ✅ ベストプラクティスと例シナリオ
- ✅ v6.0機能との統合

### v6.0 (2025-10-XX)
- Codex-Driven Implementation（セクション15-17）
- Token効率化最適化
- 並列実行戦略
- 品質保証プロセス

### v5.0以前
- GENERIC_PROMPT_V5_EN.md参照

---

## 📝 クイックリファレンス

**継続すべき時**:
- ✅ トークン > 50K + 関連タスク + スムーズな進行

**/clearすべき時**:
- ⚠️ トークン < 30K + 大きなマイルストーンが先
- 🔴 トークン < 20K + 任意の条件

**/clear前に必ずハンドオフを作成**:
- 現在のステータス（完了、進行中、保留中）
- 環境状態（セットアップ、設定、データベース）
- 重要事項（モデルマッピング、ワークアラウンド）
- 次のステップ（優先順位、コマンド）
- 主要ファイル（説明付き参照）

**トークンゾーン**:
- 🟢 150K-200K: 自由に継続
- 🟡 50K-150K: 監視しながら継続
- 🟠 30K-50K: 次のマイルストーンで/clearを計画
- 🔴 <30K: 早めに/clear実行
- ⚫ <20K: 直ちに/clear

---

**End of GENERIC_PROMPT_V6.1_JP.md**
